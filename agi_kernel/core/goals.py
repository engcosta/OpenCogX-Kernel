"""
ðŸŽ¯ Goal Engine
==============

Creates internal motivation without user input.

Goal Types:
- REDUCE_UNCERTAINTY: Find what we don't know
- RESOLVE_CONTRADICTION: Fix conflicting knowledge
- IMPROVE_PREDICTION: Get better at forecasting
- IMPROVE_SELF_ACCURACY: Better self-assessment

Key Principle:
- Goals from users are INPUTS, not motivations
- The system must have internal drive
- If the system stops without a user â†’ it's not intelligent
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Optional
import structlog

if TYPE_CHECKING:
    from agi_kernel.core.memory import Memory
    from agi_kernel.core.world import WorldModel

logger = structlog.get_logger()


class GoalType(Enum):
    """Types of intrinsic goals."""
    REDUCE_UNCERTAINTY = "reduce_uncertainty"
    RESOLVE_CONTRADICTION = "resolve_contradiction"
    IMPROVE_PREDICTION = "improve_prediction"
    IMPROVE_SELF_ACCURACY = "improve_self_accuracy"
    EXPLORE_UNKNOWN = "explore_unknown"
    FILL_KNOWLEDGE_GAP = "fill_knowledge_gap"


@dataclass
class Goal:
    """
    Represents an intrinsic goal.
    
    Goals are generated by the system, not users.
    They drive autonomous learning.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    type: GoalType = GoalType.REDUCE_UNCERTAINTY
    description: str = ""
    priority: float = 0.5  # 0-1 scale
    expected_gain: float = 0.0  # Expected knowledge improvement
    
    # Context
    target_entity: Optional[str] = None  # What we're trying to learn about
    target_relation: Optional[str] = None  # What relation we're exploring
    
    # Status
    status: str = "pending"  # pending, active, completed, failed
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None
    
    # Outcome
    actual_gain: Optional[float] = None
    attempts: int = 0
    max_attempts: int = 3
    
    def to_dict(self) -> dict:
        """Serialize goal for storage."""
        return {
            "id": self.id,
            "type": self.type.value,
            "description": self.description,
            "priority": self.priority,
            "expected_gain": self.expected_gain,
            "target_entity": self.target_entity,
            "target_relation": self.target_relation,
            "status": self.status,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "actual_gain": self.actual_gain,
            "attempts": self.attempts,
            "max_attempts": self.max_attempts,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> Goal:
        """Deserialize goal from storage."""
        return cls(
            id=data["id"],
            type=GoalType(data["type"]),
            description=data["description"],
            priority=data.get("priority", 0.5),
            expected_gain=data.get("expected_gain", 0.0),
            target_entity=data.get("target_entity"),
            target_relation=data.get("target_relation"),
            status=data.get("status", "pending"),
            created_at=datetime.fromisoformat(data["created_at"]),
            completed_at=datetime.fromisoformat(data["completed_at"]) if data.get("completed_at") else None,
            actual_gain=data.get("actual_gain"),
            attempts=data.get("attempts", 0),
            max_attempts=data.get("max_attempts", 3),
        )


class GoalEngine:
    """
    The Goal Engine generates intrinsic motivation.
    
    Core API (Mandatory):
    - generate(memory, world) -> list[Goal]
    - prioritize(goals) -> Goal
    
    Key Constraint:
    - âŒ No Goal comes from users
    - User goals are INPUTS, not motivations
    
    Philosophy:
    - The system must want to learn even without users
    - Goals emerge from uncertainty, contradictions, and gaps
    """
    
    def __init__(self, graph_plugin=None):
        """
        Initialize the Goal Engine.
        
        Args:
            graph_plugin: Optional Neo4j plugin for knowledge gap detection
        """
        self.active_goals: dict[str, Goal] = {}
        self.completed_goals: list[Goal] = []
        self.failed_goals: list[Goal] = []
        self.manual_goals: list[Goal] = []
        self.graph_plugin = graph_plugin
        
        logger.info("goal_engine_initialized")

    def add(self, goal: Goal) -> None:
        """
        Add a manual goal to the engine.
        
        Args:
            goal: The goal to add
        """
        self.manual_goals.append(goal)
        logger.info("manual_goal_added", goal_id=goal.id, description=goal.description)
    
    async def generate(self, memory: Memory, world: WorldModel) -> list[Goal]:
        """
        Generate intrinsic goals from the current state.
        
        Analyzes:
        - Uncertainty in the world model
        - Contradictions in memory
        - Knowledge gaps
        - Prediction failures
        
        Args:
            memory: The memory system
            world: The world model
            
        Returns:
            List of generated goals
        """
        goals: list[Goal] = []
        
        # 0. Include pending manual goals
        for goal in self.manual_goals:
            if goal.status == "pending":
                # Boost priority of manual goals to ensure they are picked
                goal.priority = max(goal.priority, 1.0)
                goals.append(goal)
        
        # 1. Detect uncertainty (low confidence states)
        uncertainty_goals = self._detect_uncertainty(world)
        goals.extend(uncertainty_goals)
        
        # 2. Detect contradictions
        contradiction_goals = self._detect_contradictions(memory)
        goals.extend(contradiction_goals)
        
        # 3. Detect knowledge gaps (from graph)
        if self.graph_plugin:
            gap_goals = await self._detect_knowledge_gaps()
            goals.extend(gap_goals)
        
        # 4. Analyze failed episodes for improvement
        failure_goals = self._analyze_failures(memory)
        goals.extend(failure_goals)
        
        # 5. Explore unexplored areas
        exploration_goals = self._generate_exploration_goals(memory, world)
        goals.extend(exploration_goals)
        
        logger.info(
            "goals_generated",
            count=len(goals),
            types=[g.type.value for g in goals],
        )
        
        return goals
    
    def _detect_uncertainty(self, world: WorldModel) -> list[Goal]:
        """Find states with low confidence."""
        goals = []
        
        for state in world.states.values():
            confidence = world.get_confidence(state)
            
            if confidence < 0.5:
                goal = Goal(
                    type=GoalType.REDUCE_UNCERTAINTY,
                    description=f"Investigate uncertain state: {state.features.get('action', 'unknown')}",
                    priority=1.0 - confidence,  # Lower confidence = higher priority
                    expected_gain=0.5 - confidence,
                    target_entity=state.id,
                )
                goals.append(goal)
        
        return goals[:5]  # Limit to top 5
    
    def _detect_contradictions(self, memory: Memory) -> list[Goal]:
        """Find contradictions in memory."""
        goals = []
        
        for item1_id, item2_id, reason in memory.contradictions:
            goal = Goal(
                type=GoalType.RESOLVE_CONTRADICTION,
                description=f"Resolve contradiction: {reason}",
                priority=0.9,  # High priority
                expected_gain=0.7,
                target_entity=f"{item1_id}|{item2_id}",
            )
            goals.append(goal)
        
        return goals
    
    async def _detect_knowledge_gaps(self) -> list[Goal]:
        """Find gaps in the knowledge graph."""
        goals = []
        
        if self.graph_plugin:
            # Find entities with few relations
            gaps = await self.graph_plugin.find_knowledge_gaps()
            
            for gap in gaps[:5]:
                goal = Goal(
                    type=GoalType.FILL_KNOWLEDGE_GAP,
                    description=f"Explore relations for: {gap['entity']}",
                    priority=0.7,
                    expected_gain=0.5,
                    target_entity=gap['entity'],
                )
                goals.append(goal)
        
        return goals
    
    def _analyze_failures(self, memory: Memory) -> list[Goal]:
        """Generate goals from failed episodes."""
        goals = []
        
        failed_episodes = memory.get_failed_episodes(limit=10)
        
        # Group failures by topic
        failure_topics: dict[str, int] = {}
        for episode in failed_episodes:
            # Extract topic from question (simplified)
            topic = episode.question[:50]
            failure_topics[topic] = failure_topics.get(topic, 0) + 1
        
        # Create goals for repeated failures
        for topic, count in failure_topics.items():
            if count >= 2:  # Repeated failure
                goal = Goal(
                    type=GoalType.IMPROVE_SELF_ACCURACY,
                    description=f"Improve understanding of: {topic}",
                    priority=min(0.9, 0.5 + (count * 0.1)),
                    expected_gain=0.6,
                )
                goals.append(goal)
        
        return goals
    
    def _generate_exploration_goals(
        self,
        memory: Memory,
        world: WorldModel,
    ) -> list[Goal]:
        """Generate goals to explore unknown areas."""
        goals = []
        
        # If we have few memories, prioritize exploration
        stats = memory.get_stats()
        if stats["semantic_count"] < 10:
            goal = Goal(
                type=GoalType.EXPLORE_UNKNOWN,
                description="Explore knowledge domain to build base understanding",
                priority=0.8,
                expected_gain=0.6,
            )
            goals.append(goal)
        
        # If world model has few transitions, explore causality
        world_stats = world.get_stats()
        if world_stats["total_transitions"] < 5:
            goal = Goal(
                type=GoalType.IMPROVE_PREDICTION,
                description="Learn causal relationships in the domain",
                priority=0.7,
                expected_gain=0.5,
            )
            goals.append(goal)
        
        return goals
    
    def prioritize(self, goals: list[Goal]) -> Goal | None:
        """
        Select the highest priority goal.
        
        Priority is based on:
        - Goal priority score
        - Expected gain
        - Current active goals (avoid duplicates)
        
        Args:
            goals: List of candidate goals
            
        Returns:
            The highest priority goal, or None if no goals
        """
        if not goals:
            logger.debug("no_goals_to_prioritize")
            return None
        
        # Filter out goals we're already working on
        active_types = {g.type for g in self.active_goals.values()}
        available = [g for g in goals if g.type not in active_types]
        
        if not available:
            available = goals  # All types active, pick from all
        
        # Sort by priority * expected_gain
        available.sort(
            key=lambda g: g.priority * g.expected_gain,
            reverse=True
        )
        
        best = available[0]
        best.status = "active"
        self.active_goals[best.id] = best
        
        logger.info(
            "goal_prioritized",
            goal_id=best.id,
            type=best.type.value,
            priority=best.priority,
        )
        
        return best
    
    def complete_goal(
        self,
        goal_id: str,
        actual_gain: float,
        success: bool = True,
    ) -> None:
        """
        Mark a goal as completed.
        
        Args:
            goal_id: The goal to complete
            actual_gain: Measured improvement
            success: Whether the goal was achieved
        """
        if goal_id not in self.active_goals:
            logger.warning("goal_not_found", goal_id=goal_id)
            return
        
        goal = self.active_goals.pop(goal_id)
        goal.completed_at = datetime.utcnow()
        goal.actual_gain = actual_gain
        
        if success:
            goal.status = "completed"
            self.completed_goals.append(goal)
        else:
            goal.status = "failed"
            self.failed_goals.append(goal)
        
        logger.info(
            "goal_completed",
            goal_id=goal_id,
            success=success,
            actual_gain=actual_gain,
        )
    
    def get_active_goals(self) -> list[Goal]:
        """Get currently active goals."""
        return list(self.active_goals.values())
    
    def get_stats(self) -> dict:
        """Get statistics about the goal engine."""
        return {
            "active_goals": len(self.active_goals),
            "completed_goals": len(self.completed_goals),
            "failed_goals": len(self.failed_goals),
            "average_actual_gain": (
                sum(g.actual_gain or 0 for g in self.completed_goals) / len(self.completed_goals)
                if self.completed_goals else 0
            ),
            "goal_success_rate": (
                len(self.completed_goals) / (len(self.completed_goals) + len(self.failed_goals))
                if (self.completed_goals or self.failed_goals) else 0
            ),
        }
